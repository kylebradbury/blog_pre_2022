{
  
    
        "post0": {
            "title": "Machine learning as a metaphor for life",
            "content": "I recently had the pleasure of speaking at the commencement ceremony for the 2021 cohort of Masters of Interdisciplinary Data Science (MIDS) students. I couldn&#39;t be prouder of their accomplishments. As I teach machine learning in the program, I figured I&#39;d share three (mostly-serious) machine learning metaphors for life: . Choose your cost function carefully. In machine learning, we set cost functions to tell the algorithm what to do: minimize error in predicting housing prices, for example. What is the cost function you’re optimizing? How much do you weight your career, family, friends, and personal creativity? A colleague of mine asks a question that I value asking myself regularly: “how can you help someone else succeed today?” – make sure your personal and professional relationships are part of your cost function. Most importantly, make sure your cost function, your pursuits, are defined by what you want and designed to guide you toward the person and professional you want to become. . | Use gradient descent to optimize your cost function. Gradient descent is an iterative optimization process, taking one small step at a time, and most importantly learning from that decision as to where to step next. Improvement comes from a daily struggle to grow, bit-by-bit, one matplotlib plot or database entry at a time. Optimizing your cost function requires taking some measured chances, where we may sometimes fail; but from the failure we learn improve. Over time, those small, consistent steps lead to growth and help us to become ever-better versions of ourselves in our profession and in our personal lives. . | Hone your ability to develop effective representations of your data through dimensionality reduction. Every experience we have visiting a new land, every idea we create to solve a problem, these are multifaceted, high dimensional experiences. These experiences have value when we share what learn, but to share, requires that we compress these sensory, cerebral, sometimes emotional experiences into a just few words or a few pictures. Anyone who has been on a job interview (or an online date) knows how challenging it can be to create an accurate representation of yourself in a few words. Communication is the act of constructing and presenting a lower dimensional version of these high dimensional thoughts or experiences. One of the most transformative tools in your toolbox is your ability to do that effectively and efficiently – a skill that will make you stand out professionally. . |",
            "url": "https://kylebradbury.github.io/blog/news/2021/05/09/ml-metaphor.html",
            "relUrl": "/news/2021/05/09/ml-metaphor.html",
            "date": " • May 9, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Making pretty plots in Python",
            "content": ". In 2007, Jiro Doke of the Mathworks (makers of Matlab) changed my perspective on what plots from programming languages had the potential to be through his fantastic piece simply titled Making Pretty Graphs1. Today, I think we could all make prettier, more professional graphs, and here I&#39;ll walk through some tips for making attractive, publication-quality plots in Python with matplotlib. . I&#39;d like to broadly classify plots into three categories: . Bad plots. Bad plots have no one in mind and typically confuse. Bad plots are quick to make, but hard for a reader to interpret. Telltale signs of a bad plot are missing axes labels, units, or some form of legend; lines or markers that are hard to distinguish from one another; a plot that is difficult to read because it either lacks necessary information or is blurry. | Decent plots. Decent plots are a tool for the author to quickly explore the data, determine the takeaways, and share that information when they are able to be present and explain the key takeaways. Decent plots have the necessary information to enable correct interpretation of the data presented. Telltale signs of decent plots are axes labels, legends, units, and distinguishable lines and markers. Decent plots are fast and practical. | Great plots. Great plots are designed with the reader in mind and clearly make a point. They have all of the telltale signs of decent plots, but take extra care to make the reader&#39;s experience as easy as possible by using color and typography for clarity and emphasis, are crystal clear in resolution, and are memorable and worthy of sharing. Great plots are for communicating with the larger world in papers, presentations, and on the web. | Making great plots takes more time, but can pay off in clarity and professionalism. Here, we&#39;ll walk through one example of transforming a decent plot into a great plot. . Start with a &quot;decent&quot; plot . Let&#39;s begin by gathering our data. Let&#39;s make up some data that consists of reporting the efficiency of three models as you vary the size of a parameter that is in square meters; we will name these three models &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;. We will also set a baseline efficiency value against which we want to compare all the models. . #collapse-hide import numpy as np import matplotlib.pyplot as plt # Create some data to plot x = [1,2,3,4,5] y1 = [3.64, 9.46, 16.95, 37.14, 68.22] y2 = [22.05, 22.49, 30.65, 53.58, 47.33] y3 = [16.82, 26.10, 49.61, 47.59, 95.82] y = [y1,y2,y3] # Store each series of the data in one list labels = [&#39;Model A&#39;, &#39;Model B&#39;, &#39;Model C&#39;] baseline = 40 . . For the simplest &quot;decent&quot; plot, we use the default settings of matplotlib and a very few lines of code, making sure that we label our axes and include a legend. This quickly produces a plot that contains all of the necessary information to interpret our data, but is not overly compelling. . #collapse-hide plt.figure(figsize=(6,5)) # Plot the baseline plt.plot([x[0],x[-1]],[baseline, baseline],label=&quot;Baseline&quot;) # Plot the three model lines for i, label in enumerate(labels): plt.plot(x,y[i],label=label) plt.xlabel(&#39;Size (m^2)&#39;) plt.ylabel(&#39;Efficieny (%)&#39;) plt.legend() plt.tight_layout() plt.savefig(&#39;decent.png&#39;) plt.show() . . This is perfect if the goal is for the author of the plot to understand the plotted data and draw conclusions. And it&#39;s likely alright for sharing around the office or lab when we&#39;re able to talk through this with a colleague and explain what the key takeaways are. But we can do better! How do we improve this plot and make it ready for a formal presentation of the material? . 1. Distinguish different types of information . First of all, it&#39;s not clear that the baseline is any different from the rest of the lines. In our data, the baseline is a single value that&#39;s plotted for comparison, and should be so distinguished in the plot. Let&#39;s start by making the baseline a different color and style from the rest of the lines to indicate it is different from the rest. . #collapse-hide plt.figure(figsize=(6,5)) # -BEGIN-CHANGES # Plot the baseline plt.plot([x[0],max(x)],[baseline, baseline],label=&quot;Baseline&quot;, color=&#39;lightgray&#39;, linestyle=&#39;--&#39;, linewidth=1) # --END CHANGES for i, label in enumerate(labels): plt.plot(x,y[i],label=label) plt.xlabel(&#39;Size (m^2)&#39;) plt.ylabel(&#39;Efficieny (%)&#39;) plt.legend() plt.tight_layout() plt.show() . . 2. Emphasize what&#39;s important by using colors strategically . The line colors in this plot are pretty random and don&#39;t distinguish between the other lines. In some cases that may be fine if there is no reason why any one line should stand out from the rest, but for our case, we want to emphasize the top performing model (Model C) and distinguish it from the rest. This can be easily accomplished by making one line a strong color, like red in this case, and using different shades of another color to group the rest (grey in this case), causing the line we&#39;re trying to emphasize to pop out. . #collapse-hide plt.figure(figsize=(6,5)) # Plot the baseline plt.plot([x[0],max(x)],[baseline, baseline],label=&quot;Baseline&quot;, color=&#39;lightgray&#39;, linestyle=&#39;--&#39;, linewidth=1) # Define a nice color palette: colors = [&#39;#2B2F42&#39;,&#39;#8D99AE&#39;,&#39;#EF233C&#39;] # -BEGIN-CHANGES # Plot each of the main lines for i, label in enumerate(labels): # Line plt.plot(x,y[i],label=label, color=colors[i], linewidth=2) # --END CHANGES plt.xlabel(&#39;Size (m^2)&#39;) plt.ylabel(&#39;Efficieny (%)&#39;) plt.legend() plt.tight_layout() plt.show() . . The right choice of colors may be one of the most simplest ways to make your plots look unique and professional. Plots made with defaults settings are often recognizable; I can often tell whether the author of a plot used Excel, matplotlib, or ggplot2 just by the colors used in the plot and the default aesthetic. . Consider using tools to help you choose custom color palettes for your own aesthetic. There are some great options available. The colors for this plot were chosen using Coolors (the link brings you to the specific color palette used for this plot). There are some other great tools for selecting color palettes including Paletton if you want to dive deeper into color theory and Color Brewer which can create palettes with lots of colors (up to 12 colors). . 3. Ditch the box . Our plot is already telling a much more compelling story, but there is still room for improvement. Edward Tufte, author of a number of influential data visualization books, introduced the concept of the data-to-ink ratio for plots, which states that the most &quot;ink&quot; (for the digital age, think pixels) in a chart should be devoted to displaying the data and not used for other components. Applying that principle here, the box doesn&#39;t really add value. We just need some axes. Let&#39;s remove the top and right components of the box, and leave only the y-ticks on the left of the plot. . #collapse-hide plt.figure(figsize=(6,5)) # Plot the baseline plt.plot([x[0],max(x)],[baseline, baseline],label=&quot;Baseline&quot;, color=&#39;lightgray&#39;, linestyle=&#39;--&#39;, linewidth=1) # Define a nice color palette: colors = [&#39;#2B2F42&#39;,&#39;#8D99AE&#39;,&#39;#EF233C&#39;] # Plot each of the main lines for i, label in enumerate(labels): # Line plt.plot(x,y[i],label=label, color=colors[i], linewidth=2) # -BEGIN-CHANGES # Hide the all but the bottom spines (axis lines) ax = plt.gca() ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;left&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # Only show ticks on the left and bottom spines ax.yaxis.set_ticks_position(&#39;left&#39;) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_bounds(min(x),max(x)) # --END CHANGES plt.xlabel(&#39;Size (m^2)&#39;) plt.ylabel(&#39;Efficieny (%)&#39;) plt.legend() plt.tight_layout() plt.show() . . This helps our reader focus in on the content of the plot, since there&#39;s little else to distract the reader. . 4. Make the legend be effortless to read . Legends are vital for interpreting the plot, but having a separate legend in a line plot adds in an additional layer of effort for the reader to refer back and forth to the legend to understand the data. With the reader in mind, we can make this easier, buy putting the label of the legend right at the end of the plot and coloring the text of the legend the same as the line color to make the act entirely effortless. We&#39;ll also set the x-ticks to be whole numbers to clean up the x-axis as well. . #collapse-hide plt.figure(figsize=(6,5)) # Plot the baseline plt.plot([x[0],max(x)],[baseline, baseline],label=&quot;Baseline&quot;, color=&#39;lightgray&#39;, linestyle=&#39;--&#39;, linewidth=1) # -BEGIN-CHANGES # Plot the baseline text plt.text(x[-1]*1.01,baseline,&quot;Baseline&quot;, color=&#39;lightgray&#39;, fontweight=&#39;bold&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;) # --END CHANGES # Define a nice color palette: colors = [&#39;#2B2F42&#39;,&#39;#8D99AE&#39;,&#39;#EF233C&#39;] # Plot each of the main lines for i, label in enumerate(labels): # Line plt.plot(x,y[i],label=label, color=colors[i], linewidth=2) # -BEGIN-CHANGES # Text plt.text(x[-1]*1.01,y[i][-1],label, color=colors[i], fontweight=&#39;bold&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;) # --END CHANGES # Hide the all but the bottom spines (axis lines) ax = plt.gca() ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;left&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # Only show ticks on the left and bottom spines ax.yaxis.set_ticks_position(&#39;left&#39;) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_bounds(min(x),max(x)) # -BEGIN-CHANGES plt.xticks(np.arange(min(x),max(x)+1)) # --END CHANGES plt.xlabel(&#39;Size (m^2)&#39;) plt.ylabel(&#39;Efficieny (%)&#39;) # plt.legend() # REMOVE THE ORIGINAL LEGEND plt.tight_layout() plt.show() . . 5. Size fonts for the reader . Fonts can also add legibility and professionalism. Let&#39;s increase the font size across the plot to make the text more legible. We&#39;ll also enable TeX typesetting in our labels so that the exponent is displayed properly in the x-axis label as $m^2$ rather than m^2. . #collapse-hide plt.figure(figsize=(6,5)) # -BEGIN-CHANGES # Define font sizes SIZE_DEFAULT = 14 SIZE_LARGE = 16 plt.rc(&#39;font&#39;, family=&#39;Roboto&#39;) # controls default font plt.rc(&#39;font&#39;, weight=&#39;normal&#39;) # controls default font plt.rc(&#39;font&#39;, size=SIZE_DEFAULT) # controls default text sizes plt.rc(&#39;axes&#39;, titlesize=SIZE_LARGE) # fontsize of the axes title plt.rc(&#39;axes&#39;, labelsize=SIZE_LARGE) # fontsize of the x and y labels plt.rc(&#39;xtick&#39;, labelsize=SIZE_DEFAULT) # fontsize of the tick labels plt.rc(&#39;ytick&#39;, labelsize=SIZE_DEFAULT) # fontsize of the tick labels # --END CHANGES # Plot the baseline plt.plot([x[0],max(x)],[baseline, baseline],label=&quot;Baseline&quot;, color=&#39;lightgray&#39;, linestyle=&#39;--&#39;, linewidth=1) # Plot the baseline text plt.text(x[-1]*1.01,baseline,&quot;Baseline&quot;, color=&#39;lightgray&#39;, fontweight=&#39;bold&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;) # Define a nice color palette: colors = [&#39;#2B2F42&#39;,&#39;#8D99AE&#39;,&#39;#EF233C&#39;] # Plot each of the main lines for i, label in enumerate(labels): # Line plt.plot(x,y[i],label=label, color=colors[i], linewidth=2) # Text plt.text(x[-1]*1.01,y[i][-1],label, color=colors[i], fontweight=&#39;bold&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;) # Hide the all but the bottom spines (axis lines) ax = plt.gca() ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;left&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # Only show ticks on the left and bottom spines ax.yaxis.set_ticks_position(&#39;left&#39;) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_bounds(min(x),max(x)) # -BEGIN-CHANGES plt.xlabel(r&#39;Size ($m^2$)&#39;) # Enable TeX typesetting of the superscript # --END CHANGES- plt.ylabel(&#39;Efficieny (%)&#39;) plt.tight_layout() plt.show() . . 6. Make your figure crystal clear by saving at a high resolution . The final step is to save the figure to a crystal clear image file to be used in a presentation, publication, or whatever it may be. You&#39;ll want to save your figure to be sufficiently high resolution so it is not blurry when you use it. You&#39;ll certainly want the resolution to be at least 150 dots per inch (DPI) for web applications (for higher resolution monitors), with 300 DPI and above appropriate for printing. There is a tradeoff between resolution and file size that needs to be made in each case. . I always recommend setting your figure size explicitly as well, to meet the needs of your particular application. . #collapse-hide plt.figure(figsize=(6,5)) # Define font sizes SIZE_DEFAULT = 14 SIZE_LARGE = 16 plt.rc(&#39;font&#39;, family=&#39;Roboto&#39;) # controls default font plt.rc(&#39;font&#39;, weight=&#39;normal&#39;) # controls default font plt.rc(&#39;font&#39;, size=SIZE_DEFAULT) # controls default text sizes plt.rc(&#39;axes&#39;, titlesize=SIZE_LARGE) # fontsize of the axes title plt.rc(&#39;axes&#39;, labelsize=SIZE_LARGE) # fontsize of the x and y labels plt.rc(&#39;xtick&#39;, labelsize=SIZE_DEFAULT) # fontsize of the tick labels plt.rc(&#39;ytick&#39;, labelsize=SIZE_DEFAULT) # fontsize of the tick labels # Plot the baseline plt.plot([x[0],max(x)],[baseline, baseline],label=&quot;Baseline&quot;, color=&#39;lightgray&#39;, linestyle=&#39;--&#39;, linewidth=1) # Plot the baseline text plt.text(x[-1]*1.01,baseline,&quot;Baseline&quot;, color=&#39;lightgray&#39;, fontweight=&#39;bold&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;) # Define a nice color palette: colors = [&#39;#2B2F42&#39;,&#39;#8D99AE&#39;,&#39;#EF233C&#39;] # Plot each of the main lines for i, label in enumerate(labels): # Line plt.plot(x,y[i],label=label, color=colors[i], linewidth=2) # Text plt.text(x[-1]*1.01,y[i][-1],label, color=colors[i], fontweight=&#39;bold&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;) # Hide the all but the bottom spines (axis lines) ax = plt.gca() ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;left&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # Only show ticks on the left and bottom spines ax.yaxis.set_ticks_position(&#39;left&#39;) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_bounds(min(x),max(x)) plt.xlabel(r&#39;Size ($m^2$)&#39;) plt.ylabel(&#39;Efficieny (%)&#39;) plt.tight_layout() # -BEGIN-CHANGES plt.savefig(&#39;great.png&#39;, dpi=300) # --END CHANGES . . . Other recommendations . Style guides . One way to develop a consistent, professional style of plot is to create or adopt a style guide that lays out practices regarding colors, fonts, and organization. A style guide can transform the act of making compelling, plots into a routine process and providing consisten professionalism. My personal favorite example is the style guide from the Urban Institute, which gives examples of multiple types of plots, typography, color palettes, and even template for producing them. . Visualization tools: matplotlib and alternatives . You might be asking, in a world with wonderful plotting tools like Altair, Bokeh, Plot.ly, and Seaborn, why would we use a lower level plotting tool like matplotlib? In a word: customization. matplotlib is among the most highly customizable Python plotting tools available and allows us to adjust our plots in ways that may not be possible with other tools. The change we made with the legend in the plots above would have been challenging, if not impossible, in many other tools. matplotlib can create publication-quality graphics that tell your data story your way without the need for any additional dependencies. . Depending on your needs, however, the other plotting tools mentioned above may be worth your consideration, especially if you&#39;re planning on deploying interactive graphics on the web, in which matplotlib lacks capabilities. And if you need full customization for a web-based presentation of plot, I&#39;d recommend moving away from Python and consider using D3.js. It&#39;s likely the best tool for highly customizable web-based data graphics currently available, but requires significant knowledge of Javascript and some time to ramp up on the syntax. . The greatest value of a picture is when it forces us to notice what we never expected to see. John Tukey . 1. Jiro Doke was guest blogging on Loren on the Art of MATLAB↩ .",
            "url": "https://kylebradbury.github.io/blog/tutorial/2020/06/21/pretty-plots.html",
            "relUrl": "/tutorial/2020/06/21/pretty-plots.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Purpose of this blog",
            "content": "Writing is thinking. To write well is to think clearly. David McCullough . Early in my career, I was told that writing was the single most important action I could take for clear thinking, creativity, and productivity. At the time, I promptly ignored that excellent advice and wrote when I had a deadline to meet and rarely more. If there&#39;s anything I&#39;ve learned over my career thus far is how vitally important the act of writing is for clear and coherent thinking and for developing new ideas. . I&#39;m writing this blog, then, for two purposes:primarily to share some musings on machine learning, energy, and other research concepts that I hope may be of interest to others, perhaps even to you; secondarily in so doing I organize my own thoughts. This blog will be organized into three types of content: . Research discussions and summaries on machine learning and/or energy systems. | Tutorials on technical concepts relevant to machine learning, data science, and computational programming. | Practices that have been professionally useful related to presentation, reproducibility, and organization relevant to the research process and research translation. |",
            "url": "https://kylebradbury.github.io/blog/news/2020/06/15/purpose.html",
            "relUrl": "/news/2020/06/15/purpose.html",
            "date": " • Jun 15, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://kylebradbury.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://kylebradbury.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}